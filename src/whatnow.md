# "What happens now?"

Now? Let's go practice development.  
  
I recommend you to just write a simple silly application, and play around.
Whatever you do wrong now won't hurt anyone, so _go nuts_.  
A simple guessing game, a program to read a file and replace every '.' with an
'!'. Write a library that provides support for string handling,
or perhaps create something with a database using the sqlite3 library,
if you want more of a challenge.  
  
Don't get discouraged by the compiler telling you what is wrong, or by people,
in case you ask for help via the internet.  
"It's important to be humble, and remember that you are probably not the best
around, but you can always improve, and you can always enjoy that process."  
_-LazyPurple_
  
Don't be afraid to ask people for help, it can save a lot of stress. How
complicated a program can get once it uses heap memory or threads
is well known by a lot of people. Especially with the C programming language.  
  
Speaking of journey, I want to remind that C was featured here only for the sake
of teaching. In case you grew attached to this language, remember that you can
like flawed things such as this language, but don't let your preference cloud
your vision on reality.  
The C programming language is in **most** cases not a good choice for actual
production, and this is coming from me,
a guy who has a strong emotional attachment to this language.  
  
If you want to first try a simpler language that looks C-ish but is easier to
steer, consider Go.  
Please note that this language is not so much oriented towards low level system
programming.  
Writing an operating system or a performance heavy game in Go while possible,
is a bit unorthodox.  
<https://go.dev>  
  
If you want a more modern language that is in a technical sense closer to C,
check Zig out.  
At the time of writing this, it is not yet production ready,
but I am pretty sure that they will get there.  
<https://ziglang.org>  
  
If you want a low level language that produces more stable binaries, consider
using Rust.  
However the path of a rustacean is not an easy trail to walk.  
<https://www.rust-lang.org>  

At least try these languages out over the years.  
  
If the above didn't hook you, maybe one of the many good languages out
there will do. Just try some out, and do research for what your application
needs before choosing a language. You could make a game in 100% Python or a
website in C++, but that doesn't mean it makes sense to do so.  
  
Programming languages are tools like a shovel or a pickax, and you wouldn't try
to dig into fine dirt with a pickax, right? Different languages can work
together and compliment each other.  
  
So go out there, automate some tedious processes with any programming language,
a shell script, or some file workflow related business with a well written
Makefile, and tell them Schoki sent you.  

_Plus 10 points for every reference you get ;)_
